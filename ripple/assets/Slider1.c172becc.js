import{f as e,r as t,o as s,c as i,w as r,b as n}from"./app.c4cbb42c.js";import{p as a,V as o,av as h,X as l,aw as c,ax as d,q as u,ay as g,v as m,r as p,f as v,i as x,j as f,az as y,aA as w}from"./trois.module.b64db74f.js";import{g as P,P as z}from"./index.25f9ce66.js";class S{constructor(e){Object.entries(e).forEach((([e,t])=>{this[e]=t})),this.o3d=new a,this.uProgress={value:0},this.uvScale=new o,this.initMaterial(),this.initPlane()}initMaterial(){this.material=new h({side:l,transparent:!0,map:this.texture,onBeforeCompile:e=>{e.uniforms.progress=this.uProgress,e.uniforms.uvScale={value:this.uvScale},e.vertexShader="\n          uniform float progress;\n          uniform vec2 uvScale;\n\n          attribute vec3 offset;\n          attribute vec3 rotation;\n          attribute vec2 uvOffset;\n\n          mat3 rotationMatrixXYZ(vec3 r)\n          {\n            float cx = cos(r.x);\n            float sx = sin(r.x);\n            float cy = cos(r.y);\n            float sy = sin(r.y);\n            float cz = cos(r.z);\n            float sz = sin(r.z);\n\n            return mat3(\n               cy * cz, cx * sz + sx * sy * cz, sx * sz - cx * sy * cz,\n              -cy * sz, cx * cz - sx * sy * sz, sx * cz + cx * sy * sz,\n                    sy,               -sx * cy,                cx * cy\n            );\n          }\n        "+e.vertexShader,e.vertexShader=e.vertexShader.replace("#include <uv_vertex>","\n          #include <uv_vertex>\n          vUv = vUv * uvScale + uvOffset;\n        "),e.vertexShader=e.vertexShader.replace("#include <project_vertex>","\n          mat3 rotMat = rotationMatrixXYZ(progress * rotation);\n          transformed = rotMat * transformed;\n\n          vec4 mvPosition = vec4(transformed, 1.0);\n          #ifdef USE_INSTANCING\n            mvPosition = instanceMatrix * mvPosition;\n          #endif\n\n          mvPosition.xyz += progress * offset;\n\n          mvPosition = modelViewMatrix * mvPosition;\n          gl_Position = projectionMatrix * mvPosition;\n        ")}})}initPlane(){const{width:e,wWidth:t,wHeight:s}=this.screen;this.wSize=this.size*t/e,this.nx=Math.ceil(t/this.wSize)+1,this.ny=Math.ceil(s/this.wSize)+1,this.icount=this.nx*this.ny,this.initGeometry(),this.initUV(),this.initAnimAttributes(),this.imesh&&this.o3d.remove(this.imesh),this.imesh=new c(this.bGeometry,this.material,this.icount),this.o3d.add(this.imesh);const i=new a;let r=0,n=-(t-(t-this.nx*this.wSize))/2+this.dx;for(let a=0;a<this.nx;a++){let e=-(s-(s-this.ny*this.wSize))/2+this.dy;for(let t=0;t<this.ny;t++)i.position.set(n,e,0),i.updateMatrix(),this.imesh.setMatrixAt(r++,i.matrix),e+=this.wSize;n+=this.wSize}}initGeometry(){const e=new d;e.vertices.push(new u(0,0,0)),e.vertices.push(new u(this.wSize,0,0)),e.vertices.push(new u(0,this.wSize,0)),e.vertices.push(new u(this.wSize,this.wSize,0)),e.faces.push(new g(0,2,1)),e.faces.push(new g(2,3,1)),e.faceVertexUvs[0].push([new o(0,0),new o(0,1),new o(1,0)]),e.faceVertexUvs[0].push([new o(0,1),new o(1,1),new o(1,0)]),this.dx=this.wSize/2,this.dy=this.wSize/2,e.translate(-this.dx,-this.dy,0),this.bGeometry=e.toBufferGeometry()}initAnimAttributes(){const{randFloat:e,randFloatSpread:t}=p,s=new u,i=new Float32Array(3*this.icount);for(let a=0;a<i.length;a+=3)1===this.anim?s.set(t(10),e(50,100),e(20,50)).toArray(i,a):s.set(t(20),t(20),e(20,200)).toArray(i,a);this.bGeometry.setAttribute("offset",new m(i,3));const r=new Float32Array(3*this.icount),n=4*Math.PI;for(let a=0;a<r.length;a+=3)r[a]=t(n),r[a+1]=t(n),r[a+2]=t(n);this.bGeometry.setAttribute("rotation",new m(r,3))}initUV(){const e=this.nx/this.ny,t=this.texture.image.width/this.texture.image.height;e>t?this.uvScale.set(1/this.nx,t/e/this.ny):this.uvScale.set(e/t/this.nx,1/this.ny);const s=this.uvScale.x*this.nx,i=this.uvScale.y*this.ny,r=new o,n=new Float32Array(2*this.icount);for(let a=0;a<this.nx;a++)for(let e=0;e<this.ny;e++)r.set(this.uvScale.x*a+(1-s)/2,this.uvScale.y*e+(1-i)/2).toArray(n,2*(a*this.ny+e));this.bGeometry.setAttribute("uvOffset",new m(n,2))}setTexture(e){this.texture=e,this.material.map=e,this.initUV()}resize(){this.initPlane()}}const b=e({components:{Camera:v,Renderer:x,Scene:f},props:{images:Array,events:{type:Object,default:()=>({wheel:!0,click:!0,keyup:!0})}},setup:()=>({loader:y(),progress:0,targetProgress:0}),mounted(){this.renderer=this.$refs.renderer,this.three=this.renderer.three,this.images.length<2?console.error("This slider needs at least 2 images."):this.loader.loadTextures(this.images,this.init)},unmounted(){this.loader.dispose();const e=this.renderer.renderer.domElement;e.removeEventListener("click",this.onClick),e.removeEventListener("wheel",this.onWheel),document.removeEventListener("keyup",this.onKeyup)},methods:{init(){this.initScene(),P.fromTo(this.plane1.uProgress,{value:-2},{value:0,duration:2.5,ease:z.easeOut});const e=this.renderer.renderer.domElement;this.events.click&&e.addEventListener("click",this.onClick),this.events.wheel&&e.addEventListener("wheel",this.onWheel),this.events.keyup&&document.addEventListener("keyup",this.onKeyup),this.renderer.onBeforeRender(this.updateProgress),this.renderer.onResize(this.onResize)},initScene(){const e=this.renderer.renderer,t=this.$refs.scene.scene;this.plane1=new S({renderer:e,screen:this.renderer.size,size:10,anim:1,texture:this.loader.textures[0]}),this.plane2=new S({renderer:e,screen:this.renderer.size,size:10,anim:2,texture:this.loader.textures[1]}),this.setPlanesProgress(0),this.planes=new a,this.planes.add(this.plane1.o3d),this.planes.add(this.plane2.o3d),t.add(this.planes)},onResize(){this.plane1.resize(),this.plane2.resize()},onWheel(e){e.deltaY>0?this.setTargetProgress(this.targetProgress+.05):this.setTargetProgress(this.targetProgress-.05)},onClick(e){e.clientY<this.renderer.size.height/2?this.navPrevious():this.navNext()},onKeyup(e){37===e.keyCode||38===e.keyCode?this.navPrevious():39!==e.keyCode&&40!==e.keyCode||this.navNext()},navNext(){Number.isInteger(this.targetProgress)?this.setTargetProgress(this.targetProgress+1):this.setTargetProgress(Math.ceil(this.targetProgress))},navPrevious(){Number.isInteger(this.targetProgress)?this.setTargetProgress(this.targetProgress-1):this.setTargetProgress(Math.floor(this.targetProgress))},setTargetProgress(e){this.targetProgress=e,this.targetProgress<0&&(this.progress+=this.images.length,this.targetProgress+=this.images.length)},updateProgress(){const e=w(this.progress,this.targetProgress,.1),t=e-this.progress;if(0===t)return;const s=this.progress%1,i=e%1;if(t>0&&i<s||t<0&&s<i){const t=Math.floor(e)%this.images.length,s=(t+1)%this.images.length;this.plane1.setTexture(this.loader.textures[t]),this.plane2.setTexture(this.loader.textures[s])}this.progress=e,this.setPlanesProgress(this.progress%1)},setPlanesProgress(e){this.plane1.uProgress.value=e,this.plane2.uProgress.value=-1+e,this.plane1.material.opacity=1-e,this.plane2.material.opacity=e,this.plane1.o3d.position.z=e,this.plane2.o3d.position.z=e-1}}});b.render=function(e,a,o,h,l,c){const d=t("Camera"),u=t("Scene"),g=t("Renderer");return s(),i(g,{ref:"renderer",antialias:"",resize:""},{default:r((()=>[n(d,{ref:"camera",position:{z:150}},null,512),n(u,{ref:"scene"},null,512)])),_:1},512)};const A={components:{Slider:b},data:()=>({images:[{src:"/assets/images/img1.jpg"},{src:"/assets/images/img2.jpg"},{src:"/assets/images/img3.jpg"},{src:"/assets/images/img4.jpg"}]})};A.render=function(e,r,n,a,o,h){const l=t("Slider");return s(),i(l,{images:o.images},null,8,["images"])};export default A;
