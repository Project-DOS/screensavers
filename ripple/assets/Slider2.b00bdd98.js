import{f as e,r as t,o as s,c as r,w as n,b as i}from"./app.c4cbb42c.js";import{y as a,S as o,D as g,V as h,aB as l,i as c,j as u,az as m,aA as d}from"./trois.module.b64db74f.js";import{g as v,P as p}from"./index.25f9ce66.js";function f(e){let t,s,r;const n={value:null},i={value:new h(.5,.5)},l={value:0},c={value:new h(0,0)},u={value:new h(1,1)};return t=new a(2,2,1,1),s=new o({transparent:!0,uniforms:{map:n,center:i,strength:l,uvOffset:c,uvScale:u},vertexShader:"\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",fragmentShader:"\n        uniform sampler2D map;\n        uniform vec2 center;\n        uniform float strength;\n        uniform vec2 uvOffset;\n        uniform vec2 uvScale;\n        varying vec2 vUv;\n\n        float random(vec3 scale, float seed) {\n          /* use the fragment position for a different seed per-pixel */\n          return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n        }\n        \n        void main() {\n          vec2 tUv = vUv * uvScale + uvOffset;\n          if (abs(strength) > 0.001) {\n            vec4 color = vec4(0.0);\n            float total = 0.0;\n            vec2 toCenter = center * uvScale + uvOffset - tUv;\n            \n            /* randomize the lookup values to hide the fixed number of samples */\n            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n            \n            for (float t = 0.0; t <= 20.0; t++) {\n              float percent = (t + offset) / 20.0;\n              float weight = 2.0 * (percent - percent * percent);\n              vec4 texel = texture2D(map, tUv + toCenter * percent * strength);\n\n              /* switch to pre-multiplied alpha to correctly blur transparent images */\n              texel.rgb *= texel.a;\n\n              color += texel * weight;\n              total += weight;\n            }\n\n            gl_FragColor = color / total;\n\n            /* switch back from pre-multiplied alpha */\n            gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n            gl_FragColor.a = 1.0 - abs(strength);\n          } else {\n            gl_FragColor = texture2D(map, tUv);\n          }\n        }\n      "}),r=new g(t,s),{geometry:t,material:s,mesh:r,uCenter:i,uStrength:l,setMap:function(e){n.value=e,m()},updateUV:m};function m(){const t=e.size.ratio,s=n.value.image.width/n.value.image.height;c.value.set(0,0),u.value.set(1,1),s>t?(u.value.x=t/s,c.value.x=(1-u.value.x)/2):(u.value.y=s/t,c.value.y=(1-u.value.y)/2)}}const P=e({components:{OrthographicCamera:l,Renderer:c,Scene:u},props:{images:Array,events:{type:Object,default:()=>({wheel:!0,click:!0,keyup:!0})}},setup(){const e=new h;return{loader:m(),center:e,progress:0,targetProgress:0}},mounted(){this.renderer=this.$refs.renderer,this.three=this.renderer.three,this.images.length<2?console.error("This slider needs at least 2 images."):this.loader.loadTextures(this.images,this.init)},unmounted(){this.loader.dispose();const e=this.renderer.renderer.domElement;e.removeEventListener("click",this.onClick),e.removeEventListener("wheel",this.onWheel),document.removeEventListener("keyup",this.onKeyup)},methods:{init(){this.initScene(),v.fromTo(this.image1.uStrength,{value:-2},{value:0,duration:2.5,ease:p.easeOut});const e=this.renderer.renderer.domElement;this.events.click&&e.addEventListener("click",this.onClick),this.events.wheel&&e.addEventListener("wheel",this.onWheel),this.events.keyup&&document.addEventListener("keyup",this.onKeyup),this.renderer.onBeforeRender(this.animate),this.renderer.onResize(this.onResize)},initScene(){const e=this.$refs.scene.scene;this.image1=new f(this.renderer),this.image1.setMap(this.loader.textures[0]),this.image2=new f(this.renderer),this.image2.setMap(this.loader.textures[1]),this.setImagesProgress(0),e.add(this.image1.mesh),e.add(this.image2.mesh)},animate(){const{positionN:e}=this.renderer.three.pointer;this.center.copy(e).divideScalar(2).addScalar(.5),this.image1.uCenter.value.lerp(this.center,.1),this.image2.uCenter.value.lerp(this.center,.1),this.updateProgress()},onResize(){this.image1.updateUV(),this.image2.updateUV()},onWheel(e){e.deltaY>0?this.setTargetProgress(this.targetProgress+.05):this.setTargetProgress(this.targetProgress-.05)},onClick(e){e.clientY<this.renderer.size.height/2?this.navPrevious():this.navNext()},onKeyup(e){37===e.keyCode||38===e.keyCode?this.navPrevious():39!==e.keyCode&&40!==e.keyCode||this.navNext()},navNext(){Number.isInteger(this.targetProgress)?this.setTargetProgress(this.targetProgress+1):this.setTargetProgress(Math.ceil(this.targetProgress))},navPrevious(){Number.isInteger(this.targetProgress)?this.setTargetProgress(this.targetProgress-1):this.setTargetProgress(Math.floor(this.targetProgress))},setTargetProgress(e){this.targetProgress=e,this.targetProgress<0&&(this.progress+=this.images.length,this.targetProgress+=this.images.length)},updateProgress(){const e=d(this.progress,this.targetProgress,.1),t=e-this.progress;if(0===t)return;const s=this.progress%1,r=e%1;if(t>0&&r<s||t<0&&s<r){const t=Math.floor(e)%this.images.length,s=(t+1)%this.images.length;this.image1.setMap(this.loader.textures[t]),this.image2.setMap(this.loader.textures[s])}this.progress=e,this.setImagesProgress(this.progress%1)},setImagesProgress(e){this.image1.uStrength.value=e,this.image2.uStrength.value=-1+e}}});P.render=function(e,a,o,g,h,l){const c=t("OrthographicCamera"),u=t("Scene"),m=t("Renderer");return s(),r(m,{ref:"renderer",antialias:"",resize:"",pointer:""},{default:n((()=>[i(c,{ref:"camera",position:{z:10}},null,512),i(u,{ref:"scene"},null,512)])),_:1},512)};const x={components:{Slider:P},data:()=>({images:[{src:"/assets/images/img10.jpg"},{src:"/assets/images/img6.jpg"},{src:"/assets/images/img7.jpg"},{src:"/assets/images/img8.jpg"},{src:"/assets/images/img2.jpg"}]})};x.render=function(e,n,i,a,o,g){const h=t("Slider");return s(),r(h,{images:o.images},null,8,["images"])};export default x;
