{
  "code": "#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\n\n//\n// Edited By AquaVase\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n// Note: This shader is a fairly standard 2D composition with two layers. The digits\n// are produced with bespoke signed distance functions (the fact that 2020 has only two diferent\n// digits made the process easier).\n// The background is itslef a composition of 3 layers of cellular bokeh with some color tweaks\n// similar to techniques shown in BigWings tutorials.\n//\n// There is no huge technical feat but I wanted to create a warm and colorfull image.\n// Tell me what you think :D\n\n#define S(a,b,c) smoothstep(a,b,c)\n\n// Borrowed from BigWIngs (random 1 -\u003e 4)\nvec4 N14(float t) {\n\treturn fract(sin(t*vec4(123., 104., 145., 24.))*vec4(657., 345., 879., 154.));\n}\n\n// Compute a randomized Bokeh spot inside a grid cell\nfloat bokehSpot(vec2 uv, vec2 id, float decimation)\n{\n    float accum = 0.0;\n\n    for (float x = -1.0; x \u003c= 1.0; x += 1.0)\n    {\n        for (float y = -1.0; y \u003c= 1.0; y += 1.0)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 cellId = id + offset;\n            vec4 rnd = N14(mod(cellId.x, 300.0) * 25.3 + mod(cellId.y, 300.0) * 6.67);\n\n            vec2 cellUV = uv - offset + rnd.yz * 0.5;\n\n            float dst = length(cellUV);\n\n            float radSeed = sin(time * 0.02 + rnd.x * 40.0);\n            float rad =  (abs(radSeed) - decimation) / (1.0 - decimation);\n\n            float intensity = S(rad, rad - 0.15, dst);\n\n            accum += intensity;\n        }\n    }\n\n    return accum;\n}\n\n// Computes a random layer of bokeh spots\nfloat bokehLayer(vec2 uv, float decimation)\n{\n    vec2 id = floor(uv);\n    vec2 cellUV = (uv - id) - vec2(0.5, 0.5) ;\n\n    float intensity = bokehSpot(cellUV, id, decimation);\n\n    return intensity;\n}\n\n\n// Computes the bokeh background\nvec3 bokeh(vec2 uv)\n{\n    //accumulates several layers of bokeh\n    float intensity = bokehLayer(uv * 0.2 + vec2(time * 0.3, 0.0), 0.9) * 0.2;\n    //intensity += bokehLayer(uv * 0.8 + vec2(200.0 + iTime * 0.3, 134.0), 0.9) * 0.3;\n    intensity += bokehLayer(uv * 0.5 + vec2(0.0 + time * 0.3, 334.0), 0.95) * 0.15;\n    intensity += bokehLayer(uv * 0.1 + vec2(time * 0.3, 99.0), 0.95) * 0.05;\n\n    float cDist = max(0.0, 1.0 - length(uv) * 0.05);\n\n    intensity = cDist + intensity;\n\n    // Vary color with intensity\n    // First color is the blue\n    // Second color is the green\n    vec3 chroma = mix(vec3(0.350, .71, .953), vec3(.327, .804, .623), uv.y * 0.1 + 0.4 + intensity * 0.4);\n\n    return chroma * intensity;\n}\n\n\n// Final composition\nvoid main( void )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*gl_FragCoord.xy-resolution.xy)/resolution.y;\n    uv *= 6.0;\n\n    vec3 bg = bokeh(uv);\n\n    bg.rgb -= uv.y * 0.01;\n\n    vec3 col = bg;\n\n    // Gamma correction to make the image warmer\n    float gamma = 0.8;\n    col.rgb = pow(col.rgb, vec3(gamma));\n\n    gl_FragColor = vec4(col,1.0);\n}\n\n",
  "user": "c3a069f"
}
